# 다른 언어로 성장하기

작년 4월까지 Java (Groovy) / Spring 을 사용하면서 커리어를 쌓다가, 최근 인프랩으로 이직을 하면서 Node.js (JS / TS) 에서 커리어를 쌓고 있다.    
  
처음 Node.js를 만났을때는 2016년이였는데, 당시엔 "Node.js와 Express를 활용한 블로그 API 2시간 만에 만들기" 같은 류의 컨텐츠가 유행이였다.  
  
생산성이 강조된 것은 느껴졌으나, 엔터프라이즈 아키텍처를 적용하기엔 도구나 생태계, 프레임워크 성숙도 등이 당시 부족한 경험치를 가진 내 눈에는 규모있는 팀에서도 쓸 수 있을까 하는 의구심만 갖고 있었다.  
(이렇게 주력으로 쓸 일이 있을줄이야!)  
  
많은 시간이 지나면서 Node.js 진영은 기존 생태계와는 다른 형태로 많이 발전되었다.  
  
> 물론 최근에 NestJS와 TypeORM이 활발하게 사용되면서 기본적인 프레임워크 설계나 컨셉이 C# & .Net & EF 나 Java & Spring & JPA 와 굉장히 유사해지고 있는게 느껴지기도 한다.  
  
비슷하지만, 각 진영마다 추구하는바가 달라서 배우는 점들이 많다.  
  
  
대표적인 예로 로거 (Logger) 의 사용법이다.  
  
JVM에서 로거는 [SLF4J](https://www.slf4j.org/) 기반의 `Static Logger`를 주로 사용한다.  
왜 이게 보편적인 방법이 된 건지는 정확하게 기억하지 못한다.  
내가 코딩교육을 배우

* TS 에서는 logger를 DI로 항상 처리한다
	* 도메인 객체에서 부수효과가 있는 로거를 자연스럽게 사용하지 않게 된다
	* 순수 객체를 만들기 위해 자연스럽게 노력하고, 부수효과 계층 (서비스, 컨트롤러, 레파지토리) 에 로거를 집중 시킨다

https://stackoverflow.com/a/9915056/264697

* async/await 가 지원되니 async/await가 있는 함수는 부수효과를 일으키는 함수임을 인지할 수 있어, 자연스럽게 부수효과 함수와 순수함수를 격리시키게 된다.

대표적인 테스트 프레임워크인 [Jest](https://jestjs.io/) 를 통해서 배운점도 많았다.  
Jest는 JUnit이나 Kotest에 비해 굉장히 다양한 기능을 지원하는 테스트 프레임워크이다.  

하지만 Jest가 [모듈 모킹 (Module Mocking)](https://www.daleseo.com/jest-mock-modules/) 기능을 너무 잘 지원해서 그런지... 테스트 하기가 너무 쉽다.  
**외부모듈까지 모킹이 되기 때문에** 의존성 디자인의 중요성을 알기가 너무 어렵다.  
의존성 주입보다는 항상 모듈 시스템을 후킹할 수 있는 외부 도구에 자꾸 의존하게 개발자를 유도한다고 느껴진다.  
Jest가 의도한 것은 아니지만, Jest를 처음 테스트 도구로 접한 사람이라고 하면 당연히 **모든 영역을 모킹으로 해결할 수 있기 때문에** 의존성 디자인에 대해 신경쓸 이유가 없어진다.  

예전 글에서도 이와 같이 의존성이 망가지는 냄새를 숨기게 되는 것에 대해 이야기를 나눈적이 있다. 

* [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320)

**테스트 하기가 어려울정도로 의존성과 인터페이스 설계가 망가진 상태에서도** 테스트가 쉬운것은 **의존성 스멜 (Dependency Smell) 을 탈취제로 숨기는** 것처럼 느껴진다. 

보통 좋은 디자인의 코드는 테스트 하기 쉽다.  
테스트 하기 쉬운 코드가 좋은 코드가 된다고 100% 확신할 수 없지만,  
테스트 하기 어려운 코드는 나쁜 코드였다.  
그래서 테스트 하기 좋은 코드인지 아닌지를 통해 코드 스멜 (Code Smell) 을 파악할 수 있다.  
  
근데 Jest라는 **모듈까지 통째로 Mocking이 가능한 테스트 환경**으로 인해서 
**테스트하기 좋은 코드, 모듈**에 대한 


반면 
JVM, Spring 진영에서는 최대한 외부 라이브러리는 추상화 시킨다

* Spring Data XXX, Spring Cloud XXX 는 하위 구현체에 대해 추상화를 시켜준다.
  * 언제든 라이브러리가 교체 되어도 내 코드가 영향을 받지 않도록 한다.



당시 사용하던 Redis Client인 [Jedis](https://github.com/redis/jedis)의 성능이 너무 좋지 못해 [Lettuce](https://lettuce.io/)로 Client를 교체해서 성능 테스트를 진행했었다.  
  
이때 **Redis Client를 교체**하면서 변경한 코드라곤 **빌드 도구에서 의존성만 교체해준것뿐**이다.  
실제 프로젝트 코드는 단 1줄도 수정할 필요가 없었다.  

* [Jedis 보다 Lettuce 를 쓰자](https://jojoldu.tistory.com/418)

좋은 추상화 계층이 있으면 외부 라이브러리 교체시에 기존 코드를 전혀 수정할 필요가 없다.

## 마무리

아마도 이제 다시 JVM 환경으로 돌아가더라도 Logger는 DI를 해서 사용할 것 같고, Logger가 침투하는 영역 역시 부수효과 (Side Effect) 메소드 내에서만 사용할 것 같다.  

Node.js 환경에서는 외부 라이브러리를 Wrapping 해서 사용하고 있다.  
Http Client인 [Got](https://www.npmjs.com/package/got) 를 그대로 쓰지 않고, 인터페이스 (`HttpClient`) 와 구현체 (`GotHttpClient`) 로 만들어서 **언제든 
